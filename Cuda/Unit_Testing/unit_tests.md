<h1>Outline of Unit Tests</h1>

<h2>Genetics Unit Tests</h2>
testing_genetics is a collection of unit tests to ensure that Adults are generated as we expect them to be. This section is most used to verify that the code in ga_crossover and genetic_algorithm both work as we expect them to. It checks this by verifying they are sorted in the order we expect and ensures that Children inherit genetic material properly from their parents. Additionally, a bunch of lower level tests are done on some of the individual functions from the genetic_algorithm or ga_crossover files.

<h3>runGeneticsUnitTests</h3>

- Sets up the CUDA Constants to be used in the rest of the genetics tests as well as setting up the rng to be used throughout the tests

- Runs all the genetics unit tests

<h3>firstParentsTest</h3>

- Uses a set of 10 children and converts them to Adults, then verifies these Adults can be properly sorted
- This is to verify nothing weird happens when converting Children to Adults and to ensure that giving ranks and distances to individuals and then sorting them works as expected

<h3>checkParentsTest</h3>

- Helper function for firstParentsTest. It holds the hand-calculated order the Adults from firstParentsTest should be sorted in. It takes in the vector theResults (which is the order that firstParentsTest put the Adults in after rank distance sorting them) and compares this to the order that they should be in

<h3>createMasks</h3>

- A function that tests if masks are being generated correctly
- It uses the different methods to make masks and then verifies that the only numbers that exist in the mask that has been generated are the ones supposed to be there
  
  - If printMask is set to true, it will print the output of the mask of each mask in the terminal so that you can visually verify it was generated properly

<h3>makeChildrenWithDifferentMethods</h3>

- Uses two known Adults to generate pairs of Children using each of the different crossOver_XXX methods and generateChildrenPair to generate the 2 children from these parents using a specific method
  
  - It calls checkReasonability (outlined below) to check that the Child has the properties we expected it would

- It attempts to make children using all the crossover methods with and with the thruster_type set to both 0 and 1  

<h3>checkReasonability</h3>

- This function has many input parameters 
  
  - c1 & c2 - the two Children generated by the parents using a specific crossover method
  - mask - which is actually just the mask used to generate these Children

    - The mask is passed in to ensure that each component of the child inherited from the correct parent
  - parentValues - holds the alphas, betas, zetas, and tripTimes for each parent. It alternates parent 1 and parent 2 values (it is parent 1's alpha, parent 2's alpha, then parent 1's beta, then parent 2's beta, etc.)
  - whichMethod - a number representing the crossover method being tested (1=crossOver_wholeRandom, 2=crossOver_average, 3=crossOver_bundleVars)
  - utcConstants - the unit testing version of the cuda constants that allows
  - printThings - indicates whether the user wants a lot of outputs or if they only want the working/not working message to print 

- Checks the mask's value at an index and makes sure it is appropriate for the given method (eg. there aren't any 3s/averages in the mask for crossOver_wholeRandom). Then it ensures that the value the child has for alpha, beta, zeta, and tripTime match the values they should have for the method and mask. For example, if the alpha index in the mask has a 1 in it and the method is not crossOver_average, then the alpha value of the second child should be parent 1's alpha avergage. The second child and not the first child should have parent 1's alpha because the mask passed into this function has been flipped and was used to generate the second Child, so Child 1's alpha should be the opposite - it should be parent 2's alpha.

<h3>getParamStuff</h3>

- Helper function for checkReasonability that uses an offset (alpha, beta, zeta, tripTime, etc.) to pull the proper parameter from a Child. Using ALPHA_OFFSET makes the function return the alpha value of the Child passed into the funtion

<h3>twentyAdultsPosAndSpeedDiffMade</h3>

- Creates 20 Adults with known tripTimes, posDiffs, and speedDiffs, but the rest of their parameters are not set, so they are likely full of random junk. They are given ranks and distances and rank distance sorted

<h3>verifyChildrenFromCrossover</h3>

- Creates Children from a set of 20 unique individuals, 20 duplicates, and 20 mixed (some unique, some duplicates). These children are generated with a variety of survivor counts - starting with all 20 Adults being potential parents, then 10, then 5, and finally only 2 of them are used to generate all 20 Children.

<h2>Planet Unit Tests</h2>
The planet methods have not been heavily unit tested, but this unit test was to confirm our assumption about how accessing the positions of planets using getCondition works.

<h2>testing_rank unit tests </h2>

<h3> dominationTest()</h3>

- dominationTest() looked at both giveRank() and giveDistance() from optimization.cu.and
- giveRank was tested to make sure it was giving correct ranks, which depended on the function dominationCheck() and based on the tests this function worked 
as expected with no changes needed to it from the previous summer's version.
- giveRank() was updated then tested to factor in errorStatus to the non-dominated sort
- giveRank() was tested to verify the indexing of the many vectors involved, and it has been confirmed that the vectors front, newFront, dominates, and dominatedByCount are all indexed and used correctly. 
- the ranks given have been verified to be correct based on tests that used nans, posDiffs and speedDiffs that were equal, and large sets with random posDiffs and speedDiffs
- giveDistance() has functioned as expected with no changes needed to the version at the start of the summer (other than the shift to vectors)
- the tests ran on giveDistance() used nans, equal posDiffs and speedDiffs and large randomized sets. The known sets were hand calculated and then compared to with the computed values and they matched.
<h3>CAtest()</h3>

- CAtest() examined how the anneal was changing based on the values for the posDiff and speedDiff and how fast it would change based on different functions
- the test itself uses two random and small values for posDiff and speedDiff and puts these through a loop that will decrease them each run. Each time it runs it will calculate the cost and then the annealing
- an excel document was later made that better outlines this process and it was found that the best annealing function for an impact mission was linear and ^4 for rendezvous.
<h3>newDuplicateTest()</h3>

- this test was made to test a new way to detect duplicates, which was comparing there posDiffs and speedDiffs to a certain tolerance. (the tolerance decided is 1e-14)
- the goal of this test was to make sure the original was not marked as a duplicate ever, but all of its clones were to be marked as duplicates
- This test also made sure the duplicate and parent vectors were filled correctly and no duplicates were parents.
- to verify these objectives, a small set was used that sometimes had many duplicates, or just one, and the results of how these duplicates were marked was printed
- NOTE: this test is currently outdated as it uses the adult struct to mark duplicates but we now use errorStatus

<h2>Sorts Unit Tests</h2>